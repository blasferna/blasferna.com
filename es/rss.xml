<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Blas Fern√°ndez</title>
    <link>http://blasferna.com/es</link>
    <description>Ingeniero de Software Paraguayo üáµüáæ, trabajando con Python, Java, PostgreSQL, MySQL, Oracle, Django, React, JavaScript, FastAPI y m√°s.</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>es</language>
    <lastBuildDate>Mon, 04 Dec 2023 10:09:55 +0000</lastBuildDate>
    <item>
      <title>Construyendo una Imagen Docker para una Aplicaci√≥n Django en Raspberry Pi</title>
      <link>/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</link>
      <description>Instal√© mi app de setlists hecho con Django en Raspberry Pi 4, superando desaf√≠os de arquitectura.</description>
      <content:encoded>&lt;p&gt;Hace unos d√≠as, decid√≠ instalar mi aplicaci√≥n personal para la elaboraci√≥n de setlists, disponible en &lt;a href="https://github.com/blasferna/songlib"&gt;GitHub&lt;/a&gt;, en mi Raspberry Pi 4. Si bien sab√≠a que podr√≠a enfrentar problemas debido a la diferencia en la arquitectura para la cual se construy√≥ la imagen de Docker, decid√≠ embarcarme en este desaf√≠o para aprender y entender los pasos correctos necesarios para que funcione.&lt;/p&gt;
&lt;h2&gt;Exploraci√≥n Inicial&lt;/h2&gt;
&lt;p&gt;Lo primero que hice fue crear mi archivo &lt;code&gt;docker-compose.yml&lt;/code&gt; para reconstruir f√°cilmente los contenedores m√°s adelante:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.1
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La aplicaci√≥n requiere una base de datos PostgreSQL, por lo que tambi√©n defin√≠ el servicio &lt;code&gt;postgres&lt;/code&gt;. La base de datos funcion√≥ correctamente, pero el servicio &lt;code&gt;songlib&lt;/code&gt; arroj√≥ el siguiente error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;exec /usr/bin/sh: exec format error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una breve b√∫squeda sugiri√≥ que este error se deb√≠a a que la imagen de Docker no estaba construida para la arquitectura &lt;code&gt;linux/arm64&lt;/code&gt;, que es la que utiliza la Raspberry Pi 4.&lt;/p&gt;
&lt;h2&gt;Documentaci√≥n Oficial de Docker&lt;/h2&gt;
&lt;p&gt;Decid√≠ recurrir a la documentaci√≥n oficial de Docker, confiando en que proporcionar√≠a los pasos correctos para hacer que una imagen de Docker funcione en arquitecturas &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentaci√≥n oficial encontr√© varias estrategias y opt√© por la &lt;code&gt;Cross-compilation&lt;/code&gt;, que es b√°sicamente compilar para varias plataformas simult√°neamente. Este proceso genera binarios compatibles con diversas arquitecturas, incluyendo &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentaci√≥n oficial, encontr√© el siguiente fragmento de &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;# syntax=docker/dockerfile:1
FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot; &amp;gt; /log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilic√© la parte relevante del ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al usar esta porci√≥n del ejemplo, es necesario emplear &lt;code&gt;buildx&lt;/code&gt; para crear las im√°genes de ahora en adelante. Como utilizo GitHub Actions para construir la imagen, tuve que adaptarlo para que utilice &lt;code&gt;buildx&lt;/code&gt;. A nivel local, en mi m√°quina de desarrollo, todo funcionaba seg√∫n lo esperado.&lt;/p&gt;
&lt;p&gt;Lleg√≥ el momento de lanzar una release de la imagen del proyecto con las modificaciones, y me llev√© una sorpresa al levantar la imagen en la Raspberry Pi: &lt;code&gt;exec /usr/bin/sh: exec format error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Angry" src="https://github.com/blasferna/blasferna.com/assets/8385910/36a1b232-24cf-4dc6-b0d7-b98c6e6099b2" /&gt;&lt;/p&gt;
&lt;p&gt;Invert√≠ un par de horas en el proceso y pens√© que utilizando la documentaci√≥n oficial no habr√≠a margen de error. Me pregunt√©, ¬øc√≥mo es posible que funcione en mi m√°quina pero no en la Raspberry Pi? Ah, claro, ¬°mi entorno de trabajo funciona con la arquitectura linux/amd64!&lt;/p&gt;
&lt;h2&gt;La Soluci√≥n&lt;/h2&gt;
&lt;p&gt;Despu√©s de varias horas de depuraci√≥n y pruebas exhaustivas, me di cuenta de que el &lt;code&gt;Dockerfile&lt;/code&gt; podr√≠a contener un error. Con confianza, copi√© y pegu√© la parte necesaria de la documentaci√≥n oficial. ¬øPodr√≠a haber omitido algo en mi emoci√≥n por encontrar una soluci√≥n?&lt;/p&gt;
&lt;p&gt;La clave radica en la siguiente l√≠nea:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De ninguna manera se puede realizar una &lt;code&gt;Cross-compilation&lt;/code&gt; al importar la imagen para la arquitectura en la que se est√° construyendo. Es decir, siempre se va a extender la imagen base, en este caso &lt;code&gt;golang:alpine&lt;/code&gt;, para &lt;code&gt;linux/amd64&lt;/code&gt;. Lo correcto en mi caso, siguiendo el ejemplo de &lt;code&gt;golang:alpine&lt;/code&gt;, ser√≠a:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Implementaci√≥n existosa&lt;/h3&gt;
&lt;p&gt;A continuaci√≥n, detallo los pasos para construir una imagen de una aplicaci√≥n Django que pueda ejecutarse en Raspberry Pi 4. Pueden consultar el proyecto que construye im√°genes tanto para &lt;code&gt;linux/amd64&lt;/code&gt; como para &lt;code&gt;linux/arm64&lt;/code&gt; en &lt;a href="https://github.com/blasferna/songlib"&gt;este enlace&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(Ten en cuenta que esto no es una gu√≠a paso a paso, por lo que he omitido algunos detalles y requisitos obvios, como la instalaci√≥n de Docker, la creaci√≥n de un proyecto Django, la explicaci√≥n de qu√© es un Dockerfile, un docker-compose, GitHub Actions, etc.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM python:3.8.16-bullseye

ARG TARGETPLATFORM
ARG BUILDPLATFORM

RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot;

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

RUN mkdir -p /code

WORKDIR /code

COPY requirements.txt /tmp/requirements.txt
RUN set -ex &amp;amp;&amp;amp; \
    pip install --upgrade pip &amp;amp;&amp;amp; \
    pip install -r /tmp/requirements.txt &amp;amp;&amp;amp; \
    rm -rf /root/.cache/
COPY . /code

EXPOSE 80

RUN python manage.py collectstatic --no-input

CMD [&amp;quot;sh&amp;quot;, &amp;quot;./runserver.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runserver.sh&lt;/code&gt; no es obligatorio, pero es una forma de automatizar algunos pasos al iniciar la aplicaci√≥n:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;python manage.py migrate
python manage.py createadminuser
gunicorn --bind :80 --workers 2 songlib.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;publish.yml&lt;/code&gt;: Este es el flujo de trabajo de GitHub Action que se ejecuta despu√©s de crear un release. Se encarga de construir y publicar la imagen en el registro de GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Publish a Docker image

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages:

 write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;: Por √∫ltimo, la definici√≥n que permite levantar la imagen tanto en una Raspberry Pi como en cualquier distribuci√≥n que utilice &lt;code&gt;linux/amd64&lt;/code&gt;. B√°sicamente, es el mismo archivo que se present√≥ al principio.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.3
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</guid>
      <category>django</category>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Realiza c√°lculos simples en tus formularios de Django utilizando django-calculation</title>
      <link>/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</link>
      <description>Esta aplicaci√≥n proporciona un widget de Django que obtiene su valor de una expresi√≥n definida en la instancia del widget.</description>
      <content:encoded>&lt;p&gt;Realiza c√°lculos simples en tus formularios de Django utilizando django-calculation.&lt;/p&gt;
&lt;h2&gt;¬øC√≥mo funciona?&lt;/h2&gt;
&lt;p&gt;La aplicaci√≥n ofrece una serie de widgets que te permiten especificar expresiones matem√°ticas y/o llamadas a funciones de JavaScript.&lt;/p&gt;
&lt;p&gt;Un ejemplo b√°sico ser√≠a realizar una multiplicaci√≥n para calcular el precio total de un registro de ventas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;amount = forms.DecimalField( 
    widget=calculation.FormulaInput('quantity*price')  
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En tiempo de ejecuci√≥n, la expresi√≥n &lt;code&gt;quantity*price&lt;/code&gt; se reemplaza por los valores correspondientes a los campos del mismo nombre presentes en el formulario.&lt;/p&gt;
&lt;p&gt;Actualmente admite expresiones de tipo f√≥rmula, as√≠ como operaciones de suma, c√°lculos de promedio, b√∫squeda del valor m√≠nimo, valor m√°ximo y conteo de registros.&lt;/p&gt;
&lt;h2&gt;Motivaci√≥n&lt;/h2&gt;
&lt;p&gt;Para ser honesto, soy demasiado perezoso para escribir c√≥digo de JavaScript en plantillas que tienen formularios que requieren alg√∫n tipo de c√°lculo matem√°tico. En un proyecto mediano o grande, la necesidad puede ser de varias cientos o miles de l√≠neas de c√≥digo.&lt;/p&gt;
&lt;p&gt;Como no tengo la necesidad de implementar bibliotecas frontend avanzadas, como React, Vue u otras disponibles, ya que el enfoque MTV de Django se adapta bastante bien a los proyectos en los que participo. Buscando una forma de evitar escribir c√≥digo de JavaScript para esas situaciones, decid√≠ probar algo similar a lo que Salesforce ofrece con FormulaField, pero en este caso algo mucho m√°s pr√°ctico centrado en lo que necesitaba.&lt;/p&gt;
&lt;p&gt;Durante varios a√±os he sido usuario de Oracle Forms 6i, que ten√≠a algo muy pr√°ctico: indicar que el contenido de un cuadro de texto se generara a partir de la ejecuci√≥n de una f√≥rmula y algo muy interesante suced√≠a cuando se hac√≠a referencia a otro cuadro de texto del mismo tipo, la ejecuci√≥n respetaba la dependencia del contenido de la f√≥rmula, es decir, se ejecutaba en cascada.&lt;/p&gt;
&lt;p&gt;Con todo eso en mente, comenc√© el desarrollo.&lt;/p&gt;
&lt;h2&gt;Proceso de desarrollo&lt;/h2&gt;
&lt;p&gt;La idea es bastante simple, en teor√≠a, ejecutar las expresiones indicadas en la definici√≥n del campo de texto en un formulario de Django, respetando las referencias que puedan tener en otras expresiones del mismo contexto y activarlas cuando se modifiquen los campos de origen.&lt;/p&gt;
&lt;h2&gt;Flujo funcional&lt;/h2&gt;
&lt;p&gt;Despu√©s de pensar en el flujo durante varios d√≠as, llegu√© a la conclusi√≥n de que podr√≠a funcionar de la siguiente manera.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos formulados:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lo primero ser√≠a identificar los campos que contienen f√≥rmulas, decid√≠ realizar la b√∫squeda seg√∫n el atributo &lt;code&gt;data-calculation&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar dependencias:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, encontrar todos los campos referenciados en las f√≥rmulas, para ello tuve que recorrer todos los campos formulados y analizar cada una de las f√≥rmulas.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Determinar el orden de ejecuci√≥n:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para determinar el orden de ejecuci√≥n tuve que usar un algoritmo que consiste en asignar un peso a cada campo formulado basado en el n√∫mero de veces que se hizo referencia a √©l, cuanto m√°s veces se haga referencia, mayor ser√° su peso y, por lo tanto, su ejecuci√≥n se considerar√° despu√©s de los campos m√°s livianos.&lt;/p&gt;
&lt;p&gt;C√≥digo utilizado para calcular el peso de los campos&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function calculateWeight(obj, weight = 0) {
    weight++;
    for (let index = 0; index &amp;lt; obj.dependencies.length; index++) {
        let o = obj.dependencies[index];
        weight = calculateWeight(o, weight);
    }
    return weight;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C√≥digo para ordenar la ejecuci√≥n&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function sortExecution() {
    for (let index = 0; index &amp;lt; calculatedFields.length; index++) {
        let obj = calculatedFields[index];
        obj.weight = calculateWeight(obj);
    }
    calculatedFields.sort(function (a, b) {
        return a.weight - b.weight;
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos de origen:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, tuve que encontrar aquellos campos que ejecutar√°n los c√°lculos, es decir, los campos de origen, aquellos que, cuando se modifican, ejecutar√°n los c√°lculos en los lugares donde se han referenciado.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Agregar eventos:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Teniendo los campos de origen, todo lo que queda es agregar el evento que desencadenar√≠a las ejecuciones, decid√≠ usar el evento &lt;code&gt;blur&lt;/code&gt; porque se activa despu√©s de perder el enfoque.&lt;/p&gt;
&lt;h2&gt;Instalaci√≥n&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pip install django-calculation 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agrega &lt;code&gt;calculation&lt;/code&gt; en INSTALLED_APPS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;INSTALLED_APPS = [
    ...
    'calculation',
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Uso&lt;/h2&gt;
&lt;p&gt;Importa &lt;code&gt;calculation&lt;/code&gt; y completa la definici√≥n.&lt;/p&gt;
&lt;h3&gt;Ejemplo&lt;/h3&gt;
&lt;p&gt;Usando el widget &lt;code&gt;FormulaInput&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django import forms

import calculation


class TestForm(forms.Form):
    quantity = forms.DecimalField()
    price = forms.DecimalField()
    amount = forms.DecimalField(
        widget=calculation.FormulaInput('quantity*price') # &amp;lt;- usando una sola expresi√≥n matem√°tica
    )
    apply_taxes = forms.BooleanField(initial=True)
    tax = forms.DecimalField(
        # usando expresiones matem√°ticas y funciones de JavaScript.
        widget=calculation.FormulaInput('apply_taxes ? parseFloat(amount/11).toFixed(2) : 0.0') 
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;django-calculation&lt;/code&gt; funciona con archivos est√°ticos y, por lo tanto, es necesario incluir los medios del formulario en el archivo de la plantilla.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-django"&gt;&amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;
    {% csrf_token %}
    {{ form }}
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En acci√≥n:&lt;/p&gt;
&lt;p&gt;&lt;img alt="calculation" src="https://user-images.githubusercontent.com/8385910/142947517-49a5d6a0-6a6c-41d6-8f14-a140ad44fa1e.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;C√≥digo abierto&lt;/h2&gt;
&lt;p&gt;Lo estuve usando durante varias semanas ajustando algunos detalles y despu√©s de un tiempo decid√≠ lanzar el proyecto con la esperanza de que sea √∫til para otras personas, ya que para m√≠ es muy pr√°ctico.&lt;/p&gt;
&lt;p&gt;Para eso tuve que aplicar algunas mejoras, como incluirlo en el administrador de paquetes Python &lt;code&gt;PyPI&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Repercusi√≥n&lt;/h3&gt;
&lt;p&gt;No pas√≥ mucho tiempo despu√©s del primer lanzamiento que recib√≠ algunos correos electr√≥nicos de usuarios que preguntaban sobre algunos detalles de la biblioteca, eso fue emocionante.&lt;/p&gt;
&lt;h3&gt;Contribuir&lt;/h3&gt;
&lt;p&gt;Si tienes alguna idea sobre c√≥mo mejorar la biblioteca o encontraste alg√∫n error, no dudes en abrir un issue en &lt;a href="https://github.com/blasferna/django-calculation/issues"&gt;https://github.com/blasferna/django-calculation/issues&lt;/a&gt;. &lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</guid>
      <category>django</category>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Mi primer posteo</title>
      <link>/http://blasferna.com/es/articles/mi-primer-posteo</link>
      <description>¬°Bienvenidos a mi blog! Este es mi primer art√≠culo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.</description>
      <content:encoded>&lt;p&gt;¬°Bienvenidos a mi blog! Este es mi primer art√≠culo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.&lt;/p&gt;
&lt;h2&gt;Por qu√© empec√© a bloguear&lt;/h2&gt;
&lt;p&gt;Creo que compartir mis ideas y experiencias puede ayudar a otros a aprender y crecer tambi√©n.&lt;/p&gt;
&lt;h2&gt;Qu√© esperar&lt;/h2&gt;
&lt;p&gt;En este blog, planeo cubrir varios temas, como tecnolog√≠a, desarrollo personal, viajes y m√°s.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/mi-primer-posteo</guid>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>
