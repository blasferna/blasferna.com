<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Blas Fernández</title>
    <link>http://blasferna.com/es</link>
    <description>Ingeniero de Software Paraguayo 🇵🇾, trabajando con Python, Java, PostgreSQL, MySQL, Oracle, Django, React, JavaScript, FastAPI y más.</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>es</language>
    <lastBuildDate>Mon, 04 Dec 2023 10:09:55 +0000</lastBuildDate>
    <item>
      <title>Construyendo una Imagen Docker para una Aplicación Django en Raspberry Pi</title>
      <link>/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</link>
      <description>Instalé mi app de setlists hecho con Django en Raspberry Pi 4, superando desafíos de arquitectura.</description>
      <content:encoded>&lt;p&gt;Hace unos días, decidí instalar mi aplicación personal para la elaboración de setlists, disponible en &lt;a href="https://github.com/blasferna/songlib"&gt;GitHub&lt;/a&gt;, en mi Raspberry Pi 4. Si bien sabía que podría enfrentar problemas debido a la diferencia en la arquitectura para la cual se construyó la imagen de Docker, decidí embarcarme en este desafío para aprender y entender los pasos correctos necesarios para que funcione.&lt;/p&gt;
&lt;h2&gt;Exploración Inicial&lt;/h2&gt;
&lt;p&gt;Lo primero que hice fue crear mi archivo &lt;code&gt;docker-compose.yml&lt;/code&gt; para reconstruir fácilmente los contenedores más adelante:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.1
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La aplicación requiere una base de datos PostgreSQL, por lo que también definí el servicio &lt;code&gt;postgres&lt;/code&gt;. La base de datos funcionó correctamente, pero el servicio &lt;code&gt;songlib&lt;/code&gt; arrojó el siguiente error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;exec /usr/bin/sh: exec format error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una breve búsqueda sugirió que este error se debía a que la imagen de Docker no estaba construida para la arquitectura &lt;code&gt;linux/arm64&lt;/code&gt;, que es la que utiliza la Raspberry Pi 4.&lt;/p&gt;
&lt;h2&gt;Documentación Oficial de Docker&lt;/h2&gt;
&lt;p&gt;Decidí recurrir a la documentación oficial de Docker, confiando en que proporcionaría los pasos correctos para hacer que una imagen de Docker funcione en arquitecturas &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación oficial encontré varias estrategias y opté por la &lt;code&gt;Cross-compilation&lt;/code&gt;, que es básicamente compilar para varias plataformas simultáneamente. Este proceso genera binarios compatibles con diversas arquitecturas, incluyendo &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación oficial, encontré el siguiente fragmento de &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;# syntax=docker/dockerfile:1
FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot; &amp;gt; /log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilicé la parte relevante del ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al usar esta porción del ejemplo, es necesario emplear &lt;code&gt;buildx&lt;/code&gt; para crear las imágenes de ahora en adelante. Como utilizo GitHub Actions para construir la imagen, tuve que adaptarlo para que utilice &lt;code&gt;buildx&lt;/code&gt;. A nivel local, en mi máquina de desarrollo, todo funcionaba según lo esperado.&lt;/p&gt;
&lt;p&gt;Llegó el momento de lanzar una release de la imagen del proyecto con las modificaciones, y me llevé una sorpresa al levantar la imagen en la Raspberry Pi: &lt;code&gt;exec /usr/bin/sh: exec format error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Angry" src="https://github.com/blasferna/blasferna.com/assets/8385910/36a1b232-24cf-4dc6-b0d7-b98c6e6099b2" /&gt;&lt;/p&gt;
&lt;p&gt;Invertí un par de horas en el proceso y pensé que utilizando la documentación oficial no habría margen de error. Me pregunté, ¿cómo es posible que funcione en mi máquina pero no en la Raspberry Pi? Ah, claro, ¡mi entorno de trabajo funciona con la arquitectura linux/amd64!&lt;/p&gt;
&lt;h2&gt;La Solución&lt;/h2&gt;
&lt;p&gt;Después de varias horas de depuración y pruebas exhaustivas, me di cuenta de que el &lt;code&gt;Dockerfile&lt;/code&gt; podría contener un error. Con confianza, copié y pegué la parte necesaria de la documentación oficial. ¿Podría haber omitido algo en mi emoción por encontrar una solución?&lt;/p&gt;
&lt;p&gt;La clave radica en la siguiente línea:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De ninguna manera se puede realizar una &lt;code&gt;Cross-compilation&lt;/code&gt; al importar la imagen para la arquitectura en la que se está construyendo. Es decir, siempre se va a extender la imagen base, en este caso &lt;code&gt;golang:alpine&lt;/code&gt;, para &lt;code&gt;linux/amd64&lt;/code&gt;. Lo correcto en mi caso, siguiendo el ejemplo de &lt;code&gt;golang:alpine&lt;/code&gt;, sería:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Implementación existosa&lt;/h3&gt;
&lt;p&gt;A continuación, detallo los pasos para construir una imagen de una aplicación Django que pueda ejecutarse en Raspberry Pi 4. Pueden consultar el proyecto que construye imágenes tanto para &lt;code&gt;linux/amd64&lt;/code&gt; como para &lt;code&gt;linux/arm64&lt;/code&gt; en &lt;a href="https://github.com/blasferna/songlib"&gt;este enlace&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(Ten en cuenta que esto no es una guía paso a paso, por lo que he omitido algunos detalles y requisitos obvios, como la instalación de Docker, la creación de un proyecto Django, la explicación de qué es un Dockerfile, un docker-compose, GitHub Actions, etc.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM python:3.8.16-bullseye

ARG TARGETPLATFORM
ARG BUILDPLATFORM

RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot;

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

RUN mkdir -p /code

WORKDIR /code

COPY requirements.txt /tmp/requirements.txt
RUN set -ex &amp;amp;&amp;amp; \
    pip install --upgrade pip &amp;amp;&amp;amp; \
    pip install -r /tmp/requirements.txt &amp;amp;&amp;amp; \
    rm -rf /root/.cache/
COPY . /code

EXPOSE 80

RUN python manage.py collectstatic --no-input

CMD [&amp;quot;sh&amp;quot;, &amp;quot;./runserver.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runserver.sh&lt;/code&gt; no es obligatorio, pero es una forma de automatizar algunos pasos al iniciar la aplicación:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;python manage.py migrate
python manage.py createadminuser
gunicorn --bind :80 --workers 2 songlib.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;publish.yml&lt;/code&gt;: Este es el flujo de trabajo de GitHub Action que se ejecuta después de crear un release. Se encarga de construir y publicar la imagen en el registro de GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Publish a Docker image

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages:

 write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;: Por último, la definición que permite levantar la imagen tanto en una Raspberry Pi como en cualquier distribución que utilice &lt;code&gt;linux/amd64&lt;/code&gt;. Básicamente, es el mismo archivo que se presentó al principio.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.3
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</guid>
      <category>django</category>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Realiza cálculos simples en tus formularios de Django utilizando django-calculation</title>
      <link>/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</link>
      <description>Esta aplicación proporciona un widget de Django que obtiene su valor de una expresión definida en la instancia del widget.</description>
      <content:encoded>&lt;p&gt;Realiza cálculos simples en tus formularios de Django utilizando django-calculation.&lt;/p&gt;
&lt;h2&gt;¿Cómo funciona?&lt;/h2&gt;
&lt;p&gt;La aplicación ofrece una serie de widgets que te permiten especificar expresiones matemáticas y/o llamadas a funciones de JavaScript.&lt;/p&gt;
&lt;p&gt;Un ejemplo básico sería realizar una multiplicación para calcular el precio total de un registro de ventas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;amount = forms.DecimalField( 
    widget=calculation.FormulaInput('quantity*price')  
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En tiempo de ejecución, la expresión &lt;code&gt;quantity*price&lt;/code&gt; se reemplaza por los valores correspondientes a los campos del mismo nombre presentes en el formulario.&lt;/p&gt;
&lt;p&gt;Actualmente admite expresiones de tipo fórmula, así como operaciones de suma, cálculos de promedio, búsqueda del valor mínimo, valor máximo y conteo de registros.&lt;/p&gt;
&lt;h2&gt;Motivación&lt;/h2&gt;
&lt;p&gt;Para ser honesto, soy demasiado perezoso para escribir código de JavaScript en plantillas que tienen formularios que requieren algún tipo de cálculo matemático. En un proyecto mediano o grande, la necesidad puede ser de varias cientos o miles de líneas de código.&lt;/p&gt;
&lt;p&gt;Como no tengo la necesidad de implementar bibliotecas frontend avanzadas, como React, Vue u otras disponibles, ya que el enfoque MTV de Django se adapta bastante bien a los proyectos en los que participo. Buscando una forma de evitar escribir código de JavaScript para esas situaciones, decidí probar algo similar a lo que Salesforce ofrece con FormulaField, pero en este caso algo mucho más práctico centrado en lo que necesitaba.&lt;/p&gt;
&lt;p&gt;Durante varios años he sido usuario de Oracle Forms 6i, que tenía algo muy práctico: indicar que el contenido de un cuadro de texto se generara a partir de la ejecución de una fórmula y algo muy interesante sucedía cuando se hacía referencia a otro cuadro de texto del mismo tipo, la ejecución respetaba la dependencia del contenido de la fórmula, es decir, se ejecutaba en cascada.&lt;/p&gt;
&lt;p&gt;Con todo eso en mente, comencé el desarrollo.&lt;/p&gt;
&lt;h2&gt;Proceso de desarrollo&lt;/h2&gt;
&lt;p&gt;La idea es bastante simple, en teoría, ejecutar las expresiones indicadas en la definición del campo de texto en un formulario de Django, respetando las referencias que puedan tener en otras expresiones del mismo contexto y activarlas cuando se modifiquen los campos de origen.&lt;/p&gt;
&lt;h2&gt;Flujo funcional&lt;/h2&gt;
&lt;p&gt;Después de pensar en el flujo durante varios días, llegué a la conclusión de que podría funcionar de la siguiente manera.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos formulados:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lo primero sería identificar los campos que contienen fórmulas, decidí realizar la búsqueda según el atributo &lt;code&gt;data-calculation&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar dependencias:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, encontrar todos los campos referenciados en las fórmulas, para ello tuve que recorrer todos los campos formulados y analizar cada una de las fórmulas.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Determinar el orden de ejecución:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para determinar el orden de ejecución tuve que usar un algoritmo que consiste en asignar un peso a cada campo formulado basado en el número de veces que se hizo referencia a él, cuanto más veces se haga referencia, mayor será su peso y, por lo tanto, su ejecución se considerará después de los campos más livianos.&lt;/p&gt;
&lt;p&gt;Código utilizado para calcular el peso de los campos&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function calculateWeight(obj, weight = 0) {
    weight++;
    for (let index = 0; index &amp;lt; obj.dependencies.length; index++) {
        let o = obj.dependencies[index];
        weight = calculateWeight(o, weight);
    }
    return weight;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Código para ordenar la ejecución&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function sortExecution() {
    for (let index = 0; index &amp;lt; calculatedFields.length; index++) {
        let obj = calculatedFields[index];
        obj.weight = calculateWeight(obj);
    }
    calculatedFields.sort(function (a, b) {
        return a.weight - b.weight;
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos de origen:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, tuve que encontrar aquellos campos que ejecutarán los cálculos, es decir, los campos de origen, aquellos que, cuando se modifican, ejecutarán los cálculos en los lugares donde se han referenciado.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Agregar eventos:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Teniendo los campos de origen, todo lo que queda es agregar el evento que desencadenaría las ejecuciones, decidí usar el evento &lt;code&gt;blur&lt;/code&gt; porque se activa después de perder el enfoque.&lt;/p&gt;
&lt;h2&gt;Instalación&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pip install django-calculation 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agrega &lt;code&gt;calculation&lt;/code&gt; en INSTALLED_APPS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;INSTALLED_APPS = [
    ...
    'calculation',
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Uso&lt;/h2&gt;
&lt;p&gt;Importa &lt;code&gt;calculation&lt;/code&gt; y completa la definición.&lt;/p&gt;
&lt;h3&gt;Ejemplo&lt;/h3&gt;
&lt;p&gt;Usando el widget &lt;code&gt;FormulaInput&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django import forms

import calculation


class TestForm(forms.Form):
    quantity = forms.DecimalField()
    price = forms.DecimalField()
    amount = forms.DecimalField(
        widget=calculation.FormulaInput('quantity*price') # &amp;lt;- usando una sola expresión matemática
    )
    apply_taxes = forms.BooleanField(initial=True)
    tax = forms.DecimalField(
        # usando expresiones matemáticas y funciones de JavaScript.
        widget=calculation.FormulaInput('apply_taxes ? parseFloat(amount/11).toFixed(2) : 0.0') 
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;django-calculation&lt;/code&gt; funciona con archivos estáticos y, por lo tanto, es necesario incluir los medios del formulario en el archivo de la plantilla.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-django"&gt;&amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;
    {% csrf_token %}
    {{ form }}
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En acción:&lt;/p&gt;
&lt;p&gt;&lt;img alt="calculation" src="https://user-images.githubusercontent.com/8385910/142947517-49a5d6a0-6a6c-41d6-8f14-a140ad44fa1e.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;Código abierto&lt;/h2&gt;
&lt;p&gt;Lo estuve usando durante varias semanas ajustando algunos detalles y después de un tiempo decidí lanzar el proyecto con la esperanza de que sea útil para otras personas, ya que para mí es muy práctico.&lt;/p&gt;
&lt;p&gt;Para eso tuve que aplicar algunas mejoras, como incluirlo en el administrador de paquetes Python &lt;code&gt;PyPI&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Repercusión&lt;/h3&gt;
&lt;p&gt;No pasó mucho tiempo después del primer lanzamiento que recibí algunos correos electrónicos de usuarios que preguntaban sobre algunos detalles de la biblioteca, eso fue emocionante.&lt;/p&gt;
&lt;h3&gt;Contribuir&lt;/h3&gt;
&lt;p&gt;Si tienes alguna idea sobre cómo mejorar la biblioteca o encontraste algún error, no dudes en abrir un issue en &lt;a href="https://github.com/blasferna/django-calculation/issues"&gt;https://github.com/blasferna/django-calculation/issues&lt;/a&gt;. &lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</guid>
      <category>django</category>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Mi primer posteo</title>
      <link>/http://blasferna.com/es/articles/mi-primer-posteo</link>
      <description>¡Bienvenidos a mi blog! Este es mi primer artículo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.</description>
      <content:encoded>&lt;p&gt;¡Bienvenidos a mi blog! Este es mi primer artículo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.&lt;/p&gt;
&lt;h2&gt;Por qué empecé a bloguear&lt;/h2&gt;
&lt;p&gt;Creo que compartir mis ideas y experiencias puede ayudar a otros a aprender y crecer también.&lt;/p&gt;
&lt;h2&gt;Qué esperar&lt;/h2&gt;
&lt;p&gt;En este blog, planeo cubrir varios temas, como tecnología, desarrollo personal, viajes y más.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/mi-primer-posteo</guid>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>
