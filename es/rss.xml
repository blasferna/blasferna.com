<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Blas Fernández</title>
    <link>http://blasferna.com/es</link>
    <description>Ingeniero de Software Paraguayo 🇵🇾, trabajando con Python, Java, PostgreSQL, MySQL, Oracle, Django, React, JavaScript, FastAPI y más.</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>es</language>
    <lastBuildDate>Thu, 17 Oct 2024 18:37:40 +0000</lastBuildDate>
    <item>
      <title>Uso efectivo de 'nonlocal' en Python</title>
      <link>/http://blasferna.com/es/articles/uso-efectivo-de-nonlocal-en-python</link>
      <description>Aprende cuándo y cómo usar la palabra clave 'nonlocal' en Python.</description>
      <content:encoded>&lt;p&gt;La palabra clave &lt;code&gt;nonlocal&lt;/code&gt; en Python se utiliza en situaciones específicas dentro de funciones anidadas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En funciones anidadas (una función dentro de otra).&lt;/li&gt;
&lt;li&gt;Cuando necesitas modificar una variable de la función externa desde la función interna.&lt;/li&gt;
&lt;li&gt;Cuando la variable a modificar no es global, sino del ámbito de la función externa.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def funcion_externa():
    x = 10

    def funcion_interna():
        nonlocal x
        x = 20
        print(f&amp;quot;x interna: {x}&amp;quot;)

    print(f&amp;quot;x antes: {x}&amp;quot;)
    funcion_interna()
    print(f&amp;quot;x después: {x}&amp;quot;)

funcion_externa()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Resultado:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x antes: 10
x interna: 20
x después: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nonlocal x&lt;/code&gt; indica que &lt;code&gt;x&lt;/code&gt; en la función interna se refiere a la &lt;code&gt;x&lt;/code&gt; de la función externa. Sin &lt;code&gt;nonlocal&lt;/code&gt;, se crearía una nueva variable local &lt;code&gt;x&lt;/code&gt; en la función interna.&lt;/p&gt;
&lt;p&gt;Usa &lt;code&gt;nonlocal&lt;/code&gt; con precaución, ya que puede complicar la legibilidad del código. Considéralo solo cuando sea realmente necesario modificar una variable de una función externa.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/uso-efectivo-de-nonlocal-en-python</guid>
      <category>python</category>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>cht.sh: Consultas Rápidas sin Salir de la Línea de Comandos</title>
      <link>/http://blasferna.com/es/articles/cht-sh-consultas-rapidas-sin-salir-de-la-linea-de-comandos</link>
      <description>Descubre cht.sh, una herramienta que te permite obtener información rápida sobre comandos de Linux y módulos de programación directamente desde tu terminal.</description>
      <content:encoded>&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;p&gt;Muchas veces cuando estamos trabajando en un servidor que no posee una interfaz gráfica y necesitamos alguna información adicional sobre un comando que vamos a ejecutar, por ejemplo: copiar o mover un archivo, comprimir, descargar desde internet, etc.&lt;/p&gt;
&lt;p&gt;Podríamos recurrir a Google o directamente preguntarle a ChatGPT, ¿no? Sí, pero eso implicaría minimizar la terminal si estamos por &lt;a href="https://es.wikipedia.org/wiki/Secure_Shell"&gt;SSH&lt;/a&gt; y abrir el navegador o simplemente no sería posible si estamos en frente del servidor.&lt;/p&gt;
&lt;p&gt;Hoy les traigo un recurso que nos permitirá obtener una hoja de trucos (cheat sheet) de forma práctica directamente desde la terminal.&lt;/p&gt;
&lt;p&gt;El recurso es &lt;a href="http://cht.sh/"&gt;&lt;code&gt;cht.sh&lt;/code&gt;&lt;/a&gt;, que es simplemente un conjunto de páginas que retornan texto formateado para terminales y se utiliza en combinación con &lt;a href="https://es.wikipedia.org/wiki/CURL"&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Requisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Vamos a necesitar que el servidor tenga internet.&lt;/li&gt;
&lt;li&gt;Conocer el comando a utilizar.&lt;/li&gt;
&lt;li&gt;Tener instalado &lt;a href="https://es.wikipedia.org/wiki/CURL"&gt;curl&lt;/a&gt;, que ya viene preinstalado en la mayoría de los sistemas Linux y últimamente en las últimas versiones de Windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Uso&lt;/h2&gt;
&lt;p&gt;Para utilizar &lt;a href="http://cht.sh/"&gt;&lt;code&gt;cht.sh&lt;/code&gt;&lt;/a&gt; simplemente necesitamos realizar una petición con el nombre del comando o herramienta del que queremos obtener más información y seguidamente obtendremos una guía rápida con ejemplos.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;curl cht.sh/[reemplazar con el comando o herramienta deseada]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente ejemplo veremos cómo obtener una guía rápida del comando &lt;code&gt;mv&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;curl cht.sh/mv

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto nos mostrará una lista concisa de las opciones más comunes y ejemplos de uso del comando &lt;code&gt;mv&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$  curl cheat.sh/mv
 cheat:mv
# To move a file from one place to another:
mv &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;

# To move a file from one place to another and automatically overwrite if the destination file exists:
# (This will override any previous -i or -n args)
mv -f &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;

# To move a file from one place to another but ask before overwriting an existing file:
# (This will override any previous -f or -n args)
mv -i &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;

# To move a file from one place to another but never overwrite anything:
# (This will override any previous -f or -i args)
mv -n &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;

# To move listed file(s) to a directory
mv -t &amp;lt;dest&amp;gt; &amp;lt;file&amp;gt;...

 tldr:mv
# mv
# Move or rename files and directories.
# More information: &amp;lt;https://www.gnu.org/software/coreutils/mv&amp;gt;.

# Rename a file or directory when the target is not an existing directory:
mv source target

# Move a file or directory into an existing directory:
mv source existing_directory

# Move multiple files into an existing directory, keeping the filenames unchanged:
mv source1 source2 source3 existing_directory

# Do not prompt for confirmation before overwriting existing files:
mv -f source target

# Prompt for confirmation before overwriting existing files, regardless of file permissions:
mv -i source target

# Do not overwrite existing files at the target:
mv -n source target

# Move files in verbose mode, showing files after they are moved:
mv -v source target

$

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Con la información que nos ofrece es más que suficiente para completar la operación con seguridad.&lt;/p&gt;
&lt;p&gt;Además de obtener más información sobre algunos comandos de Linux, &lt;a href="http://cht.sh/"&gt;cht.sh&lt;/a&gt; también nos ofrece la posibilidad de acceder a documentaciones de módulos de lenguajes de programación, por ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;curl cht.sh/python/requests

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nos da una guía básica de cómo podemos utilizar el módulo &lt;code&gt;requests&lt;/code&gt; de Python.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#  [Since v1.2.3](https://2.python-
#  requests.org/en/master/api/requests.PreparedRequest) Requests added
#  the PreparedRequest object. As per the documentation &amp;quot;it contains the
#  exact bytes that will be sent to the server&amp;quot;.
#
#  One can use this to pretty print a request, like so:

 import requests

 req = requests.Request('POST','&amp;lt;http://stackoverflow.com&amp;gt;',headers={'X-Custom':'Test'},data='a=1&amp;amp;b=2')
 prepared = req.prepare()

 def pretty_print_POST(req):
     &amp;quot;&amp;quot;&amp;quot;
     At this point it is completely built and ready
     to be fired; it is &amp;quot;prepared&amp;quot;.

     However pay attention at the formatting used in
     this function because it is programmed to be pretty
     printed and may differ from the actual request.
     &amp;quot;&amp;quot;&amp;quot;
     print('{}\\n{}\\r\\n{}\\r\\n\\r\\n{}'.format(
         '-----------START-----------',
         req.method + ' ' + req.url,
         '\\r\\n'.join('{}: {}'.format(k, v) for k, v in req.headers.items()),
         req.body,
     ))

 pretty_print_POST(prepared)

#  which produces:

 -----------START-----------
 POST &amp;lt;http://stackoverflow.com/&amp;gt;
 Content-Length: 7
 X-Custom: Test

 a=1&amp;amp;b=2

#  Then you can send the actual request with this:

 s = requests.Session()
 s.send(prepared)

#  These links are to the latest documentation available, so they might
#  change in content:
#  [Advanced - Prepared requests](https://2.python-
#  requests.org/en/master/user/advanced/id3) and [API - Lower level
#  classes](&amp;lt;https://2.python-requests.org/en/master/api/lower-level-&amp;gt;
#  classes)
#
#  [AntonioHerraizS] [so/q/20658572] [cc by-sa 3.0]

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusión&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://cht.sh/"&gt;cht.sh&lt;/a&gt; es un recurso interesante para los administradores de sistemas y desarrolladores que trabajan frecuentemente en entornos de línea de comandos. Proporciona acceso rápido y conveniente a información crucial sobre comandos de Linux y también módulos de programación, sin necesidad de salir de la terminal. Esta eficiencia no solo ahorra tiempo, sino que también mejora la productividad al permitir a los usuarios obtener la información que necesitan sin interrumpir su flujo de trabajo.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/cht-sh-consultas-rapidas-sin-salir-de-la-linea-de-comandos</guid>
      <category>linux</category>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Visualizando el Progreso de Descarga con tqdm en Python</title>
      <link>/http://blasferna.com/es/articles/visualizando-el-progreso-de-descarga-con-tqdm-en-python</link>
      <description>Aprende a visualizar el progreso de descargas de archivos en Python usando tqdm. Este tutorial cubre la implementación básica, manejo de errores y técnicas avanzadas para mejorar la experiencia del usuario en aplicaciones CLI.</description>
      <content:encoded>&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;p&gt;En el mundo de la programación, especialmente cuando se trabaja con descargas de archivos, es crucial proporcionar a los usuarios una indicación clara del progreso de la operación. Esto no solo mejora la experiencia del usuario, sino que también ayuda a evitar la incertidumbre sobre si el programa está funcionando correctamente. Aquí es donde entra en juego la biblioteca &lt;code&gt;tqdm&lt;/code&gt; de Python.&lt;/p&gt;
&lt;p&gt;La biblioteca &lt;code&gt;tqdm&lt;/code&gt; es una herramienta poderosa y flexible que permite mostrar barras de progreso en la línea de comandos de manera sencilla y eficiente. En este tutorial, aprenderemos cómo utilizar &lt;code&gt;tqdm&lt;/code&gt; para visualizar el progreso de descargas de archivos, proporcionando una experiencia más informativa y agradable para los usuarios de nuestros programas.&lt;/p&gt;
&lt;h2&gt;Instalación&lt;/h2&gt;
&lt;p&gt;Antes de comenzar, necesitamos instalar las bibliotecas necesarias. Utilizaremos &lt;code&gt;tqdm&lt;/code&gt; para la barra de progreso y &lt;code&gt;requests&lt;/code&gt; para realizar las solicitudes HTTP. Puedes instalarlas utilizando pip:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install tqdm requests
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Implementación de la Función de Descarga&lt;/h2&gt;
&lt;p&gt;Ahora, vamos a crear una función &lt;code&gt;download&lt;/code&gt; que descarga un archivo desde una URL dada y muestra una barra de progreso utilizando &lt;code&gt;tqdm&lt;/code&gt;. Aquí está el código completo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# tqdm_download.py

import requests
from tqdm import tqdm

def download(url, dest_path):
    response = requests.get(url, stream=True, allow_redirects=True)
    total_size = int(response.headers.get('content-length', 0))
    with open(dest_path, 'wb') as file, tqdm(
        desc=dest_path,
        total=total_size,
        unit='B',
        unit_scale=True,
        unit_divisor=1024,
    ) as bar:
        for data in response.iter_content(chunk_size=1024):
            size = file.write(data)
            bar.update(size)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Explicación Detallada&lt;/h3&gt;
&lt;p&gt;Vamos a desglosar la función &lt;code&gt;download&lt;/code&gt; para entender cómo funciona:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Importación de bibliotecas&lt;/strong&gt;: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import requests
from tqdm import tqdm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Importamos &lt;code&gt;requests&lt;/code&gt; para realizar la solicitud HTTP y &lt;code&gt;tqdm&lt;/code&gt; para la barra de progreso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definición de la función&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def download(url, dest_path):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función toma dos argumentos: &lt;code&gt;url&lt;/code&gt; (la URL del archivo a descargar) y &lt;code&gt;dest_path&lt;/code&gt; (la ruta donde se guardará el archivo).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Realización de la solicitud HTTP&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;response = requests.get(url, stream=True, allow_redirects=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilizamos &lt;code&gt;requests.get()&lt;/code&gt; con &lt;code&gt;stream=True&lt;/code&gt; para obtener el contenido en fragmentos y &lt;code&gt;allow_redirects=True&lt;/code&gt; para seguir redirecciones si las hay.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Obtención del tamaño total del archivo&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;total_size = int(response.headers.get('content-length', 0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extraemos el tamaño total del archivo del encabezado 'content-length' de la respuesta HTTP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apertura del archivo de destino y configuración de tqdm&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open(dest_path, 'wb') as file, tqdm(
   desc=dest_path,
   total=total_size,
   unit='B',
   unit_scale=True,
   unit_divisor=1024,
) as bar:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Abrimos el archivo de destino en modo escritura binaria y configuramos &lt;code&gt;tqdm&lt;/code&gt; con varios parámetros para personalizar la barra de progreso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Descarga y escritura del archivo&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for data in response.iter_content(chunk_size=1024):
   size = file.write(data)
   bar.update(size)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iteramos sobre el contenido de la respuesta en fragmentos de 1024 bytes, escribimos cada fragmento en el archivo y actualizamos la barra de progreso.&lt;/p&gt;
&lt;h2&gt;Uso de la Función&lt;/h2&gt;
&lt;p&gt;Para utilizar esta función, simplemente llámala con la URL del archivo que deseas descargar y la ruta de destino:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;download('https://example.com/archivo.zip', 'archivo.zip')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto descargará el archivo &lt;code&gt;archivo.zip&lt;/code&gt; y mostrará una barra de progreso en la línea de comandos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;archivo.zip:  38%|███           | 9.21M/23.9M [00:02&amp;lt;00:02, 5.25MB/s]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Manejo de Errores&lt;/h2&gt;
&lt;p&gt;Es importante manejar posibles errores durante la descarga. Aquí hay una versión mejorada de la función que incluye manejo básico de errores:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import requests
from tqdm import tqdm
from requests.exceptions import RequestException

def download(url, dest_path):
    try:
        response = requests.get(url, stream=True, allow_redirects=True)
        response.raise_for_status()  # Levanta una excepción para códigos de estado HTTP erróneos
        total_size = int(response.headers.get('content-length', 0))
        with open(dest_path, 'wb') as file, tqdm(
            desc=dest_path,
            total=total_size,
            unit='B',
            unit_scale=True,
            unit_divisor=1024,
        ) as bar:
            for data in response.iter_content(chunk_size=1024):
                size = file.write(data)
                bar.update(size)
    except RequestException as e:
        print(f&amp;quot;Error durante la descarga: {e}&amp;quot;)
    except IOError as e:
        print(f&amp;quot;Error al escribir el archivo: {e}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Ejemplos Adicionales&lt;/h2&gt;
&lt;h3&gt;Descarga de Múltiples Archivos&lt;/h3&gt;
&lt;p&gt;Para descargar múltiples archivos en paralelo y mostrar el progreso de cada uno, puedes utilizar &lt;code&gt;concurrent.futures&lt;/code&gt; junto con &lt;code&gt;tqdm&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import concurrent.futures
from tqdm import tqdm

def download_multiple(urls, dest_paths):
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        futures = [executor.submit(download, url, path) for url, path in zip(urls, dest_paths)]
        for future in tqdm(concurrent.futures.as_completed(futures), total=len(futures), desc=&amp;quot;Total Progress&amp;quot;):
            future.result()

# Uso
urls = ['https://example.com/file1.zip', 'https://example.com/file2.zip']
paths = ['file1.zip', 'file2.zip']
download_multiple(urls, paths)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Alternativas&lt;/h2&gt;
&lt;p&gt;Aunque &lt;code&gt;tqdm&lt;/code&gt; es una excelente opción para mostrar el progreso, existen otras alternativas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/verigak/progress/"&gt;progress&lt;/a&gt;: Una biblioteca similar a &lt;code&gt;tqdm&lt;/code&gt; con algunas características adicionales.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rsalmei/alive-progress"&gt;alive-progress&lt;/a&gt;: Ofrece barras de progreso animadas y personalizables.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Textualize/rich"&gt;rich&lt;/a&gt;: Una biblioteca para crear interfaces de línea de comandos ricas, que incluye barras de progreso.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Rendimiento&lt;/h2&gt;
&lt;p&gt;El uso de &lt;code&gt;tqdm&lt;/code&gt; tiene un impacto mínimo en el rendimiento de la descarga. La sobrecarga introducida por la actualización de la barra de progreso es ínfimo en comparación con el tiempo de descarga del archivo. Sin embargo, para archivos muy pequeños o conexiones muy rápidas, podrías notar una ligera disminución en la velocidad.&lt;/p&gt;
&lt;h2&gt;Conclusión&lt;/h2&gt;
&lt;p&gt;La biblioteca &lt;code&gt;tqdm&lt;/code&gt; proporciona una manera sencilla y efectiva de mostrar el progreso de las descargas en Python. Al incorporar barras de progreso en tus scripts de descarga, puedes mejorar significativamente la experiencia del usuario y proporcionar información valiosa sobre el estado de las operaciones de larga duración.&lt;/p&gt;
&lt;p&gt;Te animo a experimentar con &lt;code&gt;tqdm&lt;/code&gt; en tus propios proyectos &lt;code&gt;CLI&lt;/code&gt;. Prueba diferentes configuraciones, personaliza el aspecto de las barras de progreso y explora cómo puedes integrarlas en aplicaciones más complejas.&lt;/p&gt;
&lt;h2&gt;Recursos Adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/tqdm/tqdm"&gt;Documentación oficial de tqdm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python-requests.org/en/latest/"&gt;Documentación de requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files"&gt;Tutorial de Python sobre manejo de archivos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/concurrency.html"&gt;Guía de Python sobre concurrencia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/visualizando-el-progreso-de-descarga-con-tqdm-en-python</guid>
      <category>python</category>
      <pubDate>Sat, 14 Sep 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Construyendo una Imagen Docker para una Aplicación Django en Raspberry Pi</title>
      <link>/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</link>
      <description>Instalé mi app de setlists hecho con Django en Raspberry Pi 4, superando desafíos de arquitectura.</description>
      <content:encoded>&lt;p&gt;Hace unos días, decidí instalar mi aplicación personal para la elaboración de setlists, disponible en &lt;a href="https://github.com/blasferna/songlib"&gt;GitHub&lt;/a&gt;, en mi Raspberry Pi 4. Si bien sabía que podría enfrentar problemas debido a la diferencia en la arquitectura para la cual se construyó la imagen de Docker, decidí embarcarme en este desafío para aprender y entender los pasos correctos necesarios para que funcione.&lt;/p&gt;
&lt;h2&gt;Exploración Inicial&lt;/h2&gt;
&lt;p&gt;Lo primero que hice fue crear mi archivo &lt;code&gt;docker-compose.yml&lt;/code&gt; para reconstruir fácilmente los contenedores más adelante:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.1
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La aplicación requiere una base de datos PostgreSQL, por lo que también definí el servicio &lt;code&gt;postgres&lt;/code&gt;. La base de datos funcionó correctamente, pero el servicio &lt;code&gt;songlib&lt;/code&gt; arrojó el siguiente error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;exec /usr/bin/sh: exec format error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una breve búsqueda sugirió que este error se debía a que la imagen de Docker no estaba construida para la arquitectura &lt;code&gt;linux/arm64&lt;/code&gt;, que es la que utiliza la Raspberry Pi 4.&lt;/p&gt;
&lt;h2&gt;Documentación Oficial de Docker&lt;/h2&gt;
&lt;p&gt;Decidí recurrir a la documentación oficial de Docker, confiando en que proporcionaría los pasos correctos para hacer que una imagen de Docker funcione en arquitecturas &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación oficial encontré varias estrategias y opté por la &lt;code&gt;Cross-compilation&lt;/code&gt;, que es básicamente compilar para varias plataformas simultáneamente. Este proceso genera binarios compatibles con diversas arquitecturas, incluyendo &lt;code&gt;linux/arm64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación oficial, encontré el siguiente fragmento de &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;# syntax=docker/dockerfile:1
FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot; &amp;gt; /log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilicé la parte relevante del ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETPLATFORM
ARG BUILDPLATFORM
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al usar esta porción del ejemplo, es necesario emplear &lt;code&gt;buildx&lt;/code&gt; para crear las imágenes de ahora en adelante. Como utilizo GitHub Actions para construir la imagen, tuve que adaptarlo para que utilice &lt;code&gt;buildx&lt;/code&gt;. A nivel local, en mi máquina de desarrollo, todo funcionaba según lo esperado.&lt;/p&gt;
&lt;p&gt;Llegó el momento de lanzar una release de la imagen del proyecto con las modificaciones, y me llevé una sorpresa al levantar la imagen en la Raspberry Pi: &lt;code&gt;exec /usr/bin/sh: exec format error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Angry" src="https://github.com/blasferna/blasferna.com/assets/8385910/36a1b232-24cf-4dc6-b0d7-b98c6e6099b2" /&gt;&lt;/p&gt;
&lt;p&gt;Invertí un par de horas en el proceso y pensé que utilizando la documentación oficial no habría margen de error. Me pregunté, ¿cómo es posible que funcione en mi máquina pero no en la Raspberry Pi? Ah, claro, ¡mi entorno de trabajo funciona con la arquitectura linux/amd64!&lt;/p&gt;
&lt;h2&gt;La Solución&lt;/h2&gt;
&lt;p&gt;Después de varias horas de depuración y pruebas exhaustivas, me di cuenta de que el &lt;code&gt;Dockerfile&lt;/code&gt; podría contener un error. Con confianza, copié y pegué la parte necesaria de la documentación oficial. ¿Podría haber omitido algo en mi emoción por encontrar una solución?&lt;/p&gt;
&lt;p&gt;La clave radica en la siguiente línea:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$BUILDPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De ninguna manera se puede realizar una &lt;code&gt;Cross-compilation&lt;/code&gt; al importar la imagen para la arquitectura en la que se está construyendo. Es decir, siempre se va a extender la imagen base, en este caso &lt;code&gt;golang:alpine&lt;/code&gt;, para &lt;code&gt;linux/amd64&lt;/code&gt;. Lo correcto en mi caso, siguiendo el ejemplo de &lt;code&gt;golang:alpine&lt;/code&gt;, sería:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM golang:alpine AS build
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Implementación existosa&lt;/h3&gt;
&lt;p&gt;A continuación, detallo los pasos para construir una imagen de una aplicación Django que pueda ejecutarse en Raspberry Pi 4. Pueden consultar el proyecto que construye imágenes tanto para &lt;code&gt;linux/amd64&lt;/code&gt; como para &lt;code&gt;linux/arm64&lt;/code&gt; en &lt;a href="https://github.com/blasferna/songlib"&gt;este enlace&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(Ten en cuenta que esto no es una guía paso a paso, por lo que he omitido algunos detalles y requisitos obvios, como la instalación de Docker, la creación de un proyecto Django, la explicación de qué es un Dockerfile, un docker-compose, GitHub Actions, etc.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;FROM --platform=$TARGETPLATFORM python:3.8.16-bullseye

ARG TARGETPLATFORM
ARG BUILDPLATFORM

RUN echo &amp;quot;I am running on $BUILDPLATFORM, building for $TARGETPLATFORM&amp;quot;

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

RUN mkdir -p /code

WORKDIR /code

COPY requirements.txt /tmp/requirements.txt
RUN set -ex &amp;amp;&amp;amp; \
    pip install --upgrade pip &amp;amp;&amp;amp; \
    pip install -r /tmp/requirements.txt &amp;amp;&amp;amp; \
    rm -rf /root/.cache/
COPY . /code

EXPOSE 80

RUN python manage.py collectstatic --no-input

CMD [&amp;quot;sh&amp;quot;, &amp;quot;./runserver.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runserver.sh&lt;/code&gt; no es obligatorio, pero es una forma de automatizar algunos pasos al iniciar la aplicación:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;python manage.py migrate
python manage.py createadminuser
gunicorn --bind :80 --workers 2 songlib.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;publish.yml&lt;/code&gt;: Este es el flujo de trabajo de GitHub Action que se ejecuta después de crear un release. Se encarga de construir y publicar la imagen en el registro de GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Publish a Docker image

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages:

 write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;: Por último, la definición que permite levantar la imagen tanto en una Raspberry Pi como en cualquier distribución que utilice &lt;code&gt;linux/amd64&lt;/code&gt;. Básicamente, es el mismo archivo que se presentó al principio.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: &amp;quot;3&amp;quot;

services:
  postgres:
    image: postgres:14.5
    ports:
      - 5432:5432
    container_name: database
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: postgres
    restart: unless-stopped

  songlib:
    image: ghcr.io/blasferna/songlib:v0.3
    container_name: songlib
    environment:
      - DEBUG=off
      - SECRET_KEY=secret
      - DB_NAME=songlib
      - DB_USER=postgres
      - DB_PASS=secret
      - DB_HOST=database
      - DB_PORT=5432
    ports:
      - 8080:80
    depends_on:
      - postgres
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/construyendo-imagen-docker-aplicacion-django-raspberry-pi</guid>
      <category>django</category>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Realiza cálculos simples en tus formularios de Django utilizando django-calculation</title>
      <link>/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</link>
      <description>Esta aplicación proporciona un widget de Django que obtiene su valor de una expresión definida en la instancia del widget.</description>
      <content:encoded>&lt;p&gt;Realiza cálculos simples en tus formularios de Django utilizando django-calculation.&lt;/p&gt;
&lt;h2&gt;¿Cómo funciona?&lt;/h2&gt;
&lt;p&gt;La aplicación ofrece una serie de widgets que te permiten especificar expresiones matemáticas y/o llamadas a funciones de JavaScript.&lt;/p&gt;
&lt;p&gt;Un ejemplo básico sería realizar una multiplicación para calcular el precio total de un registro de ventas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;amount = forms.DecimalField( 
    widget=calculation.FormulaInput('quantity*price')  
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En tiempo de ejecución, la expresión &lt;code&gt;quantity*price&lt;/code&gt; se reemplaza por los valores correspondientes a los campos del mismo nombre presentes en el formulario.&lt;/p&gt;
&lt;p&gt;Actualmente admite expresiones de tipo fórmula, así como operaciones de suma, cálculos de promedio, búsqueda del valor mínimo, valor máximo y conteo de registros.&lt;/p&gt;
&lt;h2&gt;Motivación&lt;/h2&gt;
&lt;p&gt;Para ser honesto, soy demasiado perezoso para escribir código de JavaScript en plantillas que tienen formularios que requieren algún tipo de cálculo matemático. En un proyecto mediano o grande, la necesidad puede ser de varias cientos o miles de líneas de código.&lt;/p&gt;
&lt;p&gt;Como no tengo la necesidad de implementar bibliotecas frontend avanzadas, como React, Vue u otras disponibles, ya que el enfoque MTV de Django se adapta bastante bien a los proyectos en los que participo. Buscando una forma de evitar escribir código de JavaScript para esas situaciones, decidí probar algo similar a lo que Salesforce ofrece con FormulaField, pero en este caso algo mucho más práctico centrado en lo que necesitaba.&lt;/p&gt;
&lt;p&gt;Durante varios años he sido usuario de Oracle Forms 6i, que tenía algo muy práctico: indicar que el contenido de un cuadro de texto se generara a partir de la ejecución de una fórmula y algo muy interesante sucedía cuando se hacía referencia a otro cuadro de texto del mismo tipo, la ejecución respetaba la dependencia del contenido de la fórmula, es decir, se ejecutaba en cascada.&lt;/p&gt;
&lt;p&gt;Con todo eso en mente, comencé el desarrollo.&lt;/p&gt;
&lt;h2&gt;Proceso de desarrollo&lt;/h2&gt;
&lt;p&gt;La idea es bastante simple, en teoría, ejecutar las expresiones indicadas en la definición del campo de texto en un formulario de Django, respetando las referencias que puedan tener en otras expresiones del mismo contexto y activarlas cuando se modifiquen los campos de origen.&lt;/p&gt;
&lt;h2&gt;Flujo funcional&lt;/h2&gt;
&lt;p&gt;Después de pensar en el flujo durante varios días, llegué a la conclusión de que podría funcionar de la siguiente manera.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos formulados:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lo primero sería identificar los campos que contienen fórmulas, decidí realizar la búsqueda según el atributo &lt;code&gt;data-calculation&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar dependencias:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, encontrar todos los campos referenciados en las fórmulas, para ello tuve que recorrer todos los campos formulados y analizar cada una de las fórmulas.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Determinar el orden de ejecución:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para determinar el orden de ejecución tuve que usar un algoritmo que consiste en asignar un peso a cada campo formulado basado en el número de veces que se hizo referencia a él, cuanto más veces se haga referencia, mayor será su peso y, por lo tanto, su ejecución se considerará después de los campos más livianos.&lt;/p&gt;
&lt;p&gt;Código utilizado para calcular el peso de los campos&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function calculateWeight(obj, weight = 0) {
    weight++;
    for (let index = 0; index &amp;lt; obj.dependencies.length; index++) {
        let o = obj.dependencies[index];
        weight = calculateWeight(o, weight);
    }
    return weight;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Código para ordenar la ejecución&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function sortExecution() {
    for (let index = 0; index &amp;lt; calculatedFields.length; index++) {
        let obj = calculatedFields[index];
        obj.weight = calculateWeight(obj);
    }
    calculatedFields.sort(function (a, b) {
        return a.weight - b.weight;
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar campos de origen:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Luego, tuve que encontrar aquellos campos que ejecutarán los cálculos, es decir, los campos de origen, aquellos que, cuando se modifican, ejecutarán los cálculos en los lugares donde se han referenciado.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Agregar eventos:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Teniendo los campos de origen, todo lo que queda es agregar el evento que desencadenaría las ejecuciones, decidí usar el evento &lt;code&gt;blur&lt;/code&gt; porque se activa después de perder el enfoque.&lt;/p&gt;
&lt;h2&gt;Instalación&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pip install django-calculation 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agrega &lt;code&gt;calculation&lt;/code&gt; en INSTALLED_APPS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;INSTALLED_APPS = [
    ...
    'calculation',
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Uso&lt;/h2&gt;
&lt;p&gt;Importa &lt;code&gt;calculation&lt;/code&gt; y completa la definición.&lt;/p&gt;
&lt;h3&gt;Ejemplo&lt;/h3&gt;
&lt;p&gt;Usando el widget &lt;code&gt;FormulaInput&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django import forms

import calculation


class TestForm(forms.Form):
    quantity = forms.DecimalField()
    price = forms.DecimalField()
    amount = forms.DecimalField(
        widget=calculation.FormulaInput('quantity*price') # &amp;lt;- usando una sola expresión matemática
    )
    apply_taxes = forms.BooleanField(initial=True)
    tax = forms.DecimalField(
        # usando expresiones matemáticas y funciones de JavaScript.
        widget=calculation.FormulaInput('apply_taxes ? parseFloat(amount/11).toFixed(2) : 0.0') 
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;django-calculation&lt;/code&gt; funciona con archivos estáticos y, por lo tanto, es necesario incluir los medios del formulario en el archivo de la plantilla.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-django"&gt;&amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;
    {% csrf_token %}
    {{ form }}
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En acción:&lt;/p&gt;
&lt;p&gt;&lt;img alt="calculation" src="https://user-images.githubusercontent.com/8385910/142947517-49a5d6a0-6a6c-41d6-8f14-a140ad44fa1e.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;Código abierto&lt;/h2&gt;
&lt;p&gt;Lo estuve usando durante varias semanas ajustando algunos detalles y después de un tiempo decidí lanzar el proyecto con la esperanza de que sea útil para otras personas, ya que para mí es muy práctico.&lt;/p&gt;
&lt;p&gt;Para eso tuve que aplicar algunas mejoras, como incluirlo en el administrador de paquetes Python &lt;code&gt;PyPI&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Repercusión&lt;/h3&gt;
&lt;p&gt;No pasó mucho tiempo después del primer lanzamiento que recibí algunos correos electrónicos de usuarios que preguntaban sobre algunos detalles de la biblioteca, eso fue emocionante.&lt;/p&gt;
&lt;h3&gt;Contribuir&lt;/h3&gt;
&lt;p&gt;Si tienes alguna idea sobre cómo mejorar la biblioteca o encontraste algún error, no dudes en abrir un issue en &lt;a href="https://github.com/blasferna/django-calculation/issues"&gt;https://github.com/blasferna/django-calculation/issues&lt;/a&gt;. &lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/realiza-calculos-simples-en-tus-formularios-django</guid>
      <category>django</category>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Mi primer posteo</title>
      <link>/http://blasferna.com/es/articles/mi-primer-posteo</link>
      <description>¡Bienvenidos a mi blog! Este es mi primer artículo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.</description>
      <content:encoded>&lt;p&gt;¡Bienvenidos a mi blog! Este es mi primer artículo y estoy emocionado de compartir mis pensamientos y experiencias con ustedes.&lt;/p&gt;
&lt;h2&gt;Por qué empecé a bloguear&lt;/h2&gt;
&lt;p&gt;Creo que compartir mis ideas y experiencias puede ayudar a otros a aprender y crecer también.&lt;/p&gt;
&lt;h2&gt;Qué esperar&lt;/h2&gt;
&lt;p&gt;En este blog, planeo cubrir varios temas, como tecnología, desarrollo personal, viajes y más.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">/http://blasferna.com/es/articles/mi-primer-posteo</guid>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>
